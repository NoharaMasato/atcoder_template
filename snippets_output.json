{
  "unionfine": {
    "prefix": "uf",
    "body": [
      "struct UnionFind{",
      "  vector<int> par;",
      "",
      "  UnionFind(int N): par(N){",
      "    for(int i=0;i<N;i++) par[i]=i;",
      "  }",
      "",
      "  int root(int x){",
      "    if(par[x]==x) return x;",
      "    else return par[x]=root(par[x]);",
      "  }",
      "",
      "  void unite(int x,int y){",
      "    int rx=root(x);",
      "    int ry=root(y);",
      "    if(rx!=ry) par[rx]=ry;",
      "  }",
      "",
      "  bool sameroot(int x,int y){",
      "    return root(x)==root(y);",
      "  }",
      "};"
    ],
    "description": "unionfind"
  },
  "bfs": {
    "prefix": "bfs",
    "body": [
      "queue <pair<int,int>> q;",
      "q.push({sx-1,sy-1});",
      "",
      "while(!q.empty()){",
      "  pair<int,int> now = q.front();",
      "  q.pop();",
      "  if (s[now.second][now.first]=='#') continue;",
      "  //cout << now.first << \" \" << now.second<< endl;",
      "  s[now.second][now.first]='#';",
      "  for (int i(0);i<4;i++){",
      "    pair<int,int> next = {now.first + nlx[i],now.second+nly[i]};",
      "    if (next.first < 0 || next.first >= C || next.second < 0 || next.second >= R) continue; //ここでは次のマスに進めるかどうかを見ていない。",
      "    cnt[next.second][next.first] = cnt[now.second][now.first]+1;",
      "    if (next.first == gx - 1 && next.second == gy - 1){",
      "      cout << cnt[next.second][next.first] << endl;",
      "      return 0;",
      "    }",
      "    q.push(next);",
      "  }",
      "}",
      ""
    ],
    "description": "unionfind"
  },
  "dijkstra": {
    "prefix": "dik",
    "body": [
      "#define MAX_N 100",
      "int N;",
      "int d[MAX_N]; //各頂点の最小値を入れる配列",
      "struct edge {int to,cost;};",
      "vector<edge> G[MAX_N];",
      "",
      "void dijkstra(int s){ //頂点sからの最短距離を配列dに入れる",
      "  priority_queue<P,vector<P>,greater<P>> q;//値を小さい順に出すpairは一つ目がコスト、２つ目が頂点番号",
      "  fill(d,d+N,INF);",
      "  d[s] = 0;",
      "  q.push(P(0,s));",
      "",
      "  while(!q.empty()){",
      "    P p = q.top();q.pop();",
      "    int v = p.second;",
      "    if (d[v] < p.first) continue;",
      "    for (int i(0);i<G[v].size();i++){",
      "      edge e = G[v][i];",
      "      if (d[e.to] > d[v] + e.cost){",
      "        cout << e.to << \"番目の頂点を\" << d[e.to] << \"から\" << d[v] + e.cost << \"に変更しました\" << endl;",
      "        d[e.to] = d[v] + e.cost;",
      "        q.push(P(d[e.to],e.to));",
      "      }",
      "    }",
      "  }",
      "}"
    ],
    "description": "unionfind"
  }
}